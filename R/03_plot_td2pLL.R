


# function: plot.td2pLL
#           Plot method for object of class DERmod as generated by fitDERmod OR
#           for vector of coefficients for ext3pLL model, when no DERmod object is generated
#           Uses the plotly function to create a three-dimensional, interactive plot
#           of the fitted model with data included.
# Input:
#   - DERmod:         DERmod object as genrated by fitDERmod function
#   - coefs:          Named vector with parameters for h, delta, gmma and c0
#   - dose_lim:       ranges of dose used in the plot: use first value above 0, because
#                     dose is on a logarithmic scale. Default is 1e-04
#   - time_lim:       see dose_lim. Default is (1, 7)
#   - add_data:       data.frame (numeric, columns time, dose and resp) with data.point that can
#                     be added to the plot
#   -n_grid:          Model is evaluated at equidistant grid of size n_grid^2 in dose_lim x time_lim. Default is 100.
#   - title:          Plot title as character. If default (NULL), the parameters will be printed in the title.
#   - add_ED50_line:  Logical. Should a red ED50 line be added to the plot? Default is TRUE.
# Output: A plotly plot

#' @title Plot interactive td2pLL models
#'
#' @description \code{plot.td2pLL} is the plot method for the S3 class td2pll.
#'  Model fits generated with the fit_td2pLL functions are of class
#'  \code{c("td2pLL", "nls")} and can therefore be used for this plot method.
#'  If no fitted model but a through parameters pre-specified td2pLL model
#'  shall be plotted, this can be done via the \code{td2pLL_coefs} argument.
#'  For details on the \code{td2pLL} model, see \code{\link{fit_td2pLL}}.

# td2pLL_model <- model1
plot.td2pLL <- function(td2pLL_model = NULL, td2pLL_coefs = NULL,
                        dose_lim = c(1e-04,1),
                        time_lim = c(1,7),
                        add_data = NULL, n_grid = 100, title = NULL,
                        xaxis_scale = "log",
                        yaxis_scale = "-",

                        xaxis_title = "Dose",
                        yaxis_title = "Time",
                        zaxis_title = "Response",

                        add_ED50_line = T,
                        ED50line_col = "red",
                        ED50line_width = 6){

  time_seq = seq(time_lim[1], time_lim[2], length.out = n_grid)
  dose_seq = c(0, exp(seq(log(dose_lim[1]), log(dose_lim[2]), length.out = n_grid)))
  # seq(dose_lim[1], dose_lim[2], length.out = n_grid)

  input_grid <- expand.grid(time = time_seq, dose = dose_seq) %>%
    as.data.frame()

  if(is.null(td2pLL_model) & is.null(td2pLL_coefs)){
    stop("Either the td2pLL_model argument or the td2pLL_coefs argument must be specified.")
  }

  if(!(is.null(td2pLL_model)) & !(is.null(td2pLL_coefs))){
    stop("Only td2pLL_model or td2pLL_coefs can be specified, not both.")
  }

  # calculate the responses at each grid-point
  if(!is.null(td2pLL_coefs)){
    input_grid$resp <- apply(input_grid, 1, function(x){
      ext3pLL(dose = x["dose"],
              time = x["time"],
              h = coefs["h"],
              delta = coefs["delta"],
              gamma = coefs["gamma"],
              c0 = coefs["c0"])
    }
    )
  } else {
    input_grid$resp <- predict(td2pLL_model, newdata = input_grid)
    coefs <- coef(td2pLL_model)
  }

  # make matrix-style input for plot_ly function
  input_grid <- input_grid %>% pivot_wider(names_from = dose, values_from = resp) %>%
    dplyr::select(-time) %>%
    as.matrix()

  if(is.null(title)){
    title <- paste0("h = ", round(coefs["h"], 3) ,"; delta = ", round(coefs["delta"], 3) ,";\n gamma = ",
                    round(coefs["gamma"],3) ,"; c0 = ", round(coefs["c0"], 3))
  }

  # actual plotting:

  res_plot <- plot_ly(x = dose_seq, y = time_seq, z = input_grid,
                      type="surface") %>%
    layout(title = title,
           scene = list(
             xaxis = list(title = xaxis_title,
                          tick0 = 0,
                          type = xaxis_scale),
             yaxis = list(title = yaxis_title,
                          type = yaxis_scale),
             zaxis = list(title = zaxis_title)
           ))

  # add single data points, if available
  if(!is.null(add_data)){
    res_plot <- res_plot %>% add_markers(x = add_data$dose,
                                         y = add_data$time,
                                         z = add_data$resp,
                                         marker = list(size = 2),
                                         showlegend = F)
  }

  # add ED50 line, if wanted
  if(add_ED50_line){
    add_ED50 <- data.frame(
      time = time_seq,
      ED50 = coefs["delta"] * time_seq^(-coefs["gamma"]) + coefs["c0"]
    )

    #add_ED50 <- add_ED50 %>% filter(ED50 <= 1.02)
    add_ED50$resp <- 50

    res_plot <- res_plot %>% add_trace(x = add_ED50$ED50, y = add_ED50$time, z = add_ED50$resp,
                                       type = "scatter3d", mode = "lines",
                                       showlegend = F,
                                       line = list(color = ED50line_col,
                                                   width = ED50line_width))
  }

  return(res_plot)
}
