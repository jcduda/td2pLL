


# function: plot.td2pLL
#           Plot method for object of class td2pLL as generated by fit_td2pLL OR
#           for a vector of coefficients of a td2pLL model, when no td2pLL object is generated
#           Uses the plotly function to create a three-dimensional, interactive plot
#           of the fitted model with data included.
# Input:
#   - DERmod:         DERmod object as genrated by fitDERmod function
#   - coefs:          Named vector with parameters for h, delta, gmma and c0
#   - dose_lim:       ranges of dose used in the plot: use first value above 0, because
#                     dose is on a logarithmic scale. Default is 1e-04
#   - time_lim:       see dose_lim. Default is (1, 7)
#   - add_data:       data.frame (numeric, columns time, dose and resp) with data.point that can
#                     be added to the plot
#   -n_grid:          Model is evaluated at equidistant grid of size n_grid^2 in dose_lim x time_lim. Default is 100.
#   - title:          Plot title as character. If default (NULL), the parameters will be printed in the title.
#   - add_ED50_line:  Logical. Should a red ED50 line be added to the plot? Default is TRUE.
# Output: A plotly plot

#' @title Plot interactive td2pLL models
#'
#' @description `plot.td2pLL` is the plot method for the S3 class
#' `td2pLL`.
#' Model fits generated with the fit_td2pLL functions are of class
#' `c("td2pLL", "nls")` and can therefore be used for this plot method.
#' If no fitted model but a through parameters pre-specified td2pLL model
#' shall be plotted, this can be done via the `td2pLL_coefs` argument.
#' For details on the `td2pLL` model, see [fit_td2pLL()].
#' If the `TDR` function is used which performs the two-step
#' modeling pipeline, one can apply plot.td2pLL to the `fit` list entry
#' returned by TDR, if fitting a `td2pLL` model was chosen in accordance
#' to the anova pre-test.
#' @details For further details on the td2pLL model, check [fit_td2pLL()].
#' For details on the ANOVA used, see [td2pLL_anova()]. More over,
#' the entire procedure is explained in duda et al. (2021).
#' For plotting, the `plot_ly` function of package `plotly` is used.
#' @param td2pLL_model A td2pLL object generatet via `fit_td2pLL`. If not
#' provided, alternatively, `td2pLL_coefs` can be provided.
#' @param td2pLL_coefs Named numeric vector with parameters for h, delta, gamma and c0
#' of the td2pLL model.
#' @param dose_lim Boundaries of the doses (xaxis) to be plotted. Default is
#' `c(1e-4, 1)`.
#' Note: If `xaxis_scale = "log"` (default), then `dose_lim` cannot include 0.
#' If `dose_lim` shall include the 0, set `xaxis_scale = "linear"`.
#' @param time_lim Boundaries for the time (xaxis). Default is `c(1, 7)`.
#' @param add_data Optional `data.frame` to add data points to the
#' surface plot. Must include columns `dose`, `time` and `resp`.
#' @param n_grid `Integer`. `n_grid*n_grid` is the grid for surface evaluations
#' that will be interpolated. Increase `n_grid` for smoother plot.
#' @param title Optional plot title.
#' @param xaxis_scale Scale of x-axis (Dose-Axis). Character of c("log", "linear", "-").
#' If "-" is set, then plot_ly tries to guess which scale shall be used.
#' @param yaxis_scale Scale of y-axis (Time-Axis). Character of c("log", "linear", "-").
#' If "-" is set, then plot_ly tries to guess which scale shall be used.
#' @param xaxis_title Character Title for Dose-Axis.
#' @param yaxis_title Title for Time-Axis.
#' @param zaxis_title Title for Response-Axis.
#' @param add_ED50_line Logical. Indicates if the line of EC_50 values shall be
#' annotated.
#' @param ED50_line_col Color for optionally added ED_50 line.
#' @param ED50_line_width Width for optionally added ED_50 line.


# td2pLL_model <- model1
plot.td2pLL <- function(td2pLL_model = NULL, td2pLL_coefs = NULL,
                        dose_lim = c(1e-04, 1),
                        time_lim = c(1, 7),
                        add_data = NULL,
                        n_grid = 100,
                        title = NULL,
                        xaxis_scale = "log",
                        yaxis_scale = "-",

                        xaxis_title = "Dose",
                        yaxis_title = "Time",
                        zaxis_title = "Response",

                        add_ED50_line = TRUE,
                        ED50_line_col = "red",
                        ED50_line_width = 6
                        ) {
  time_seq <- seq(time_lim[1], time_lim[2], length.out = n_grid)
  dose_seq <- c(0, exp(seq(log(dose_lim[1]), log(dose_lim[2]), length.out = n_grid)))
  # seq(dose_lim[1], dose_lim[2], length.out = n_grid)

  input_grid <- expand.grid(time = time_seq, dose = dose_seq) %>%
    as.data.frame()

  if (is.null(td2pLL_model) & is.null(td2pLL_coefs)) {
    stop("Either the td2pLL_model argument or the td2pLL_coefs argument must be specified.")
  }

  if (!(is.null(td2pLL_model)) & !(is.null(td2pLL_coefs))) {
    stop("Only td2pLL_model or td2pLL_coefs can be specified, not both.")
  }

  # calculate the responses at each grid-point
  if (!is.null(td2pLL_coefs)) {
    input_grid$resp <- apply(input_grid, 1, function(x) {
      td2pLL(
        dose = x["dose"],
        time = x["time"],
        h = coefs["h"],
        delta = coefs["delta"],
        gamma = coefs["gamma"],
        c0 = coefs["c0"]
      )
    })
  } else {
    input_grid$resp <- predict(td2pLL_model, newdata = input_grid)
    coefs <- coef(td2pLL_model)
  }

  # make matrix-style input for plot_ly function
  input_grid <- input_grid %>%
    pivot_wider(names_from = .data$dose, values_from = .data$resp) %>%
    dplyr::select(-.data$time) %>%
    as.matrix()

  if (is.null(title)) {
    title <- paste0(
      "h = ", round(coefs["h"], 3), "; delta = ", round(coefs["delta"], 3), ";\n gamma = ",
      round(coefs["gamma"], 3), "; c0 = ", round(coefs["c0"], 3)
    )
  }

  # actual plotting:

  res_plot <- plotly::plot_ly(
    x = dose_seq, y = time_seq, z = input_grid,
    type = "surface"
  ) %>%
    plotly::layout(
      title = title,
      scene = list(
        xaxis = list(
          title = xaxis_title,
          tick0 = 0,
          type = xaxis_scale
        ),
        yaxis = list(
          title = yaxis_title,
          type = yaxis_scale
        ),
        zaxis = list(title = zaxis_title)
      )
    )

  # add single data points, if available
  if (!is.null(add_data)) {
    res_plot <- res_plot %>% plotly::add_markers(
      x = add_data$dose,
      y = add_data$time,
      z = add_data$resp,
      marker = list(size = 2),
      showlegend = F
    )
  }

  # add ED50 line, if wanted
  if (add_ED50_line) {
    add_ED50 <- data.frame(
      time = time_seq,
      ED50 = coefs["delta"] * time_seq^(-coefs["gamma"]) + coefs["c0"]
    )

    # add_ED50 <- add_ED50 %>% filter(ED50 <= 1.02)
    add_ED50$resp <- 50

    res_plot <- res_plot %>% plotly::add_trace(
      x = add_ED50$ED50, y = add_ED50$time, z = add_ED50$resp,
      type = "scatter3d", mode = "lines",
      showlegend = F,
      line = list(
        color = ED50_line_col,
        width = ED50_line_width
      )
    )
  }

  return(res_plot)
}
